package it.univr.neuralnetworks;


import java.text.DecimalFormat;

import org.deeplearning4j.nn.api.Layer;
import org.deeplearning4j.nn.conf.ComputationGraphConfiguration;
import org.deeplearning4j.nn.conf.ComputationGraphConfiguration.GraphBuilder;
import org.deeplearning4j.nn.conf.NeuralNetConfiguration;
import org.deeplearning4j.nn.conf.graph.ElementWiseVertex;
import org.deeplearning4j.nn.conf.graph.ElementWiseVertex.Op;
import org.deeplearning4j.nn.conf.graph.ShiftVertex;
import org.deeplearning4j.nn.conf.layers.DenseLayer;
import org.deeplearning4j.nn.conf.layers.OutputLayer;
import org.deeplearning4j.nn.graph.ComputationGraph;
import org.nd4j.linalg.activations.impl.ActivationIdentity;
import org.nd4j.linalg.activations.impl.ActivationReLU;
import org.nd4j.linalg.api.ndarray.INDArray;
import org.nd4j.linalg.cpu.nativecpu.NDArray;
import org.nd4j.linalg.dataset.MultiDataSet;
import org.nd4j.linalg.learning.config.Adam;
import org.nd4j.linalg.lossfunctions.LossFunctions;

import net.finmath.exception.CalculationException;
import net.finmath.functions.AnalyticFormulas;
import net.finmath.montecarlo.BrownianMotion;
import net.finmath.montecarlo.BrownianMotionFromMersenneRandomNumbers;
import net.finmath.montecarlo.assetderivativevaluation.MonteCarloBlackScholesModel;
import net.finmath.time.TimeDiscretization;
import net.finmath.time.TimeDiscretizationFromArray;

/**
 * This class uses the libraries deeplearning4j and nd4j in order to create and train a neural network which has to learn if
 * an underlying process is a strict local martingale (i.e., if it has a financial bubble) or a true martingale (i.e., it has
 * no bubble) based on the call prices it generates. 
 * In particular, here we consider processes X^i=(X^i_t)_{t >= 0} following the dynamics
 *   
 * dX^i_t = (X_i+d_i)^(beta_i),  (1)
 * X_0 = x_0,
 * 
 * where d_i and beta_i are random variables, uniformly distributed in [0,0.2] and [0.5, 1.5], respectively. These are displaced CEV
 * models, and they are strict local martingales if and only if beta_i>1. In this example, we have sigma = 1.0 and x_0=2.
 * 
 * The call prices generated by this model can be computed analytically, and we do that in the class it.univr.cevprices.CevPrices.
 * We take 15 equally-spaced strikes between 1.5 and 3.0, and 20 equally-spaced maturities from 1.0 to 2.0.  
 * 
 * With these data, we train a neural network with 2 hidden layers of 60 and 20 nodes, respectively, giving it prices generated
 * in half cases by true martingale and in half cases by strict local martingales. We computing the weights and the biases via the
 * Adam algorithm with learning rate equal to 0.001 and 10 epochs. 
 * 
 * We then test it for prices generated by processes following (1) with other displacements. 
 * 
 * @author Andrea Mazzon
 *
 */
public class DeepHedgingTestBasic {


	public static void main(String[] args) throws CalculationException {
		//we use it to print the bubble probabilities
		DecimalFormat formatter = new DecimalFormat("0.00");

		//model (i.e., underlying) parameters
		double initialValue = 1;
		double riskFreeRate = 0.0;
		double volatility = 0.3;

		//option parameters
		double maturity = 1.0;	
		double strike = initialValue;


		double blackScholesPrice = AnalyticFormulas.blackScholesOptionValue(initialValue, riskFreeRate, volatility, maturity, strike);


		int seed = 1897;


		int numberOfNodesPerLayer = 30;
		int numberOfEpochs = 20;
		double learningRate = 0.001;


		//Monte Carlo time discretization parameters
		double initialTime = 0.0;
		double timeStep = 0.02;
		int numberOfTimeSteps = (int) (maturity/timeStep);
		int numberOfTimes = numberOfTimeSteps + 1; 

		TimeDiscretization times = new TimeDiscretizationFromArray(initialTime, numberOfTimeSteps, timeStep);

		//simulation parameters
		int numberOfPaths = 10000;

		int numberOfPathsToTrain = 9990;
		int numberOfPathsToTest = 10;



		GraphBuilder builder = new NeuralNetConfiguration.Builder()
				.updater(new Adam(learningRate))
				.seed(seed)
				.graphBuilder();

		String stringForPrice = "price" + 0;

		String stringForFirstHiddenLayer = "firstHiddenLayer" + 0;
		String stringForSecondHiddenLayer = "secondHiddenLayer" + 0;

		String stringForStrategy = "strategy" + 0;
		String stringForStrategyValue;

		String stringForOldCumulativeStrategyValue = "cumulativeStrategyValue" + 0;
		String stringForCumulativeStrategyValue;

		String stringForIncrement;


		builder.addInputs(stringForOldCumulativeStrategyValue).addInputs(stringForPrice).
		addLayer(stringForFirstHiddenLayer, new DenseLayer.Builder().nIn(1).nOut(numberOfNodesPerLayer).activation(new ActivationReLU()).build(), stringForPrice)
		.addLayer(stringForSecondHiddenLayer, new DenseLayer.Builder().nIn(numberOfNodesPerLayer).nOut(numberOfNodesPerLayer).activation(new ActivationReLU()).build(), stringForFirstHiddenLayer)
		.addLayer(stringForStrategy,new DenseLayer.Builder().nIn(numberOfNodesPerLayer).nOut(1).activation(new ActivationIdentity()).build(), stringForSecondHiddenLayer);

		String stringForOldPrice = "price" + 0;

		for(int timeIndex = 1; timeIndex < numberOfTimes - 1; timeIndex ++) {
			stringForPrice = "price" + timeIndex;
			stringForFirstHiddenLayer = "firstHiddenLayer" + timeIndex;
			stringForSecondHiddenLayer = "secondHiddenLayer" + timeIndex;
			stringForStrategyValue = "strategyValue" + timeIndex;
			stringForCumulativeStrategyValue  = "cumulativeStrategyValue" + timeIndex;
			stringForIncrement = "increment" + timeIndex;

			builder.addInputs(stringForPrice)
			.addVertex(stringForIncrement, new ElementWiseVertex(Op.Subtract), stringForPrice, stringForOldPrice)
			.addVertex(stringForStrategyValue, new ElementWiseVertex(Op.Product), stringForIncrement, stringForStrategy)
			.addVertex(stringForCumulativeStrategyValue, new ElementWiseVertex(Op.Add), stringForStrategyValue, stringForOldCumulativeStrategyValue)
			.addLayer(stringForFirstHiddenLayer, new DenseLayer.Builder().nIn(1).nOut(numberOfNodesPerLayer).activation(new ActivationReLU()).build(), stringForPrice)
			.addLayer(stringForSecondHiddenLayer, new DenseLayer.Builder().nIn(numberOfNodesPerLayer).nOut(numberOfNodesPerLayer).activation(new ActivationReLU()).build(), stringForFirstHiddenLayer);

			stringForStrategy = "strategy" + timeIndex;
			stringForOldPrice = "price" + timeIndex;
			stringForOldCumulativeStrategyValue  = "cumulativeStrategyValue" + timeIndex;

			builder.addLayer(stringForStrategy,new DenseLayer.Builder().nIn(numberOfNodesPerLayer).nOut(1).activation(new ActivationIdentity()).build(), stringForSecondHiddenLayer);			 

		}


		builder.addInputs("lastPrice")
		.addVertex("lastIncrement", new ElementWiseVertex(Op.Subtract), "lastPrice", stringForPrice)
		.addVertex("lastStrategyValue", new ElementWiseVertex(Op.Product), "lastIncrement", stringForStrategy)
		.addVertex("lastCumulativeStrategyValue", new ElementWiseVertex(Op.Add), "lastStrategyValue", stringForOldCumulativeStrategyValue)
		.addInputs("zero")
		.addVertex("difference", new ShiftVertex(- strike), "lastPrice")
		.addVertex("payoff", new ElementWiseVertex(Op.Max), "difference", "zero")
		.addVertex("strategyMinusPayoff",  new ElementWiseVertex(Op.Subtract), "lastCumulativeStrategyValue", "payoff")			    
		.addVertex("finalPortfolioValue", new ShiftVertex(+ blackScholesPrice), "strategyMinusPayoff")	
		.addLayer("out1", new OutputLayer.Builder().lossFunction(LossFunctions.LossFunction.MSE)
				.nIn(1).nOut(1).activation(new ActivationIdentity()).constrainAllParameters().build(), "finalPortfolioValue")
		.setOutputs("out1");

		ComputationGraphConfiguration conf = builder.build();




		ComputationGraph net = new ComputationGraph(conf);
		net.init();

		Layer finalPortfolioOutputLayer = net.getLayer("out1");

		// Get the parameters of the output layer
		INDArray weights = finalPortfolioOutputLayer.getParam("W");
		INDArray biases = finalPortfolioOutputLayer.getParam("b");

		// Set weights to one and biases to zero
		weights.assign(1.0);
		biases.assign(0.0);

		// Set weights to one and biases to zero		
		/**
		 * This method prints the prices of a call option for different initial values of the underlying, and checks
		 * if these are close to the analytic ones. This is done via assertArrayEquals, which causes a failure if, at least
		 * for an index i, there is a difference between the i-th elements of the array of analytic prices and of the prices we
		 * compute higher than tolerance.
		 */

		BrownianMotion ourDriver = new BrownianMotionFromMersenneRandomNumbers(times, 1 /* numberOfFactors */, numberOfPaths, seed);



		//we construct an object of type MonteCarloBlackScholesModel: it represents the simulation of a Black-Scholes process
		MonteCarloBlackScholesModel blackScholesProcess = new MonteCarloBlackScholesModel(initialValue, riskFreeRate, volatility, ourDriver);		


		INDArray[] inputsArrayTrain = new INDArray[numberOfTimes + 2];
		INDArray[] inputsArrayTest = new INDArray[numberOfTimes + 2];

		double[][] initialValueStrategiesTrain = new double[numberOfPathsToTrain][1];
		double[][] initialValueStrategiesTest = new double[numberOfPathsToTest][1];

		inputsArrayTrain[0] = new NDArray(initialValueStrategiesTrain); 
		inputsArrayTest[0] = new NDArray(initialValueStrategiesTest); 


		for(int timeIndex = 0; timeIndex < numberOfTimes; timeIndex ++) {
			double[][] pricesAtTimeToTrain = new double[numberOfPathsToTrain][1];
			double[][] pricesAtTimeToTest = new double[numberOfPathsToTest][1];

			for(int simulationIndex = 1; simulationIndex < numberOfPathsToTrain; simulationIndex ++) {
				pricesAtTimeToTrain[simulationIndex][0] = blackScholesProcess.getAssetValue(timeIndex, 0).get(simulationIndex);
			}
			for(int simulationIndex = numberOfPathsToTrain; simulationIndex < numberOfPaths; simulationIndex ++) {
				pricesAtTimeToTest[simulationIndex-numberOfPathsToTrain][0] = blackScholesProcess.getAssetValue(timeIndex, 0).get(simulationIndex);
			}
			inputsArrayTrain[timeIndex + 1] = new NDArray(pricesAtTimeToTrain);
			inputsArrayTest[timeIndex + 1] = new NDArray(pricesAtTimeToTest);
		}

		double[][] zerosTrain = new double[numberOfPathsToTrain][1];
		double[][] zerosTest = new double[numberOfPathsToTest][1];

		inputsArrayTrain[numberOfTimes + 1] = new NDArray(zerosTrain);
		inputsArrayTest[numberOfTimes + 1] = new NDArray(zerosTest);

		double[][] finalValuesTrain = new double[numberOfPathsToTrain][1];


		INDArray[] outputsArrayTrain = new INDArray[1];

		outputsArrayTrain[0] = new NDArray(finalValuesTrain);		

		MultiDataSet dataSetTrain = new MultiDataSet(inputsArrayTrain, outputsArrayTrain);

		for (int epochIndex = 0; epochIndex < numberOfEpochs; epochIndex ++) {
			net.fit(dataSetTrain);
		}

		INDArray[] portfolioValuesTestAsINDArray = net.output(inputsArrayTest);

		double[] portfolioValuesTest = portfolioValuesTestAsINDArray[0].toDoubleVector();

		System.out.println("Portfolio values for the test:");

		for (int simulationIndexForTest = 0; simulationIndexForTest<numberOfPathsToTest; simulationIndexForTest++) {
			System.out.println(formatter.format(portfolioValuesTest[simulationIndexForTest]));
		}

	}

}